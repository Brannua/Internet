## 可靠传输的实现机制之（停止-等待协议SW）

- 如图所示，收发双方并不局限于一条点对点的数据链路，而是基于互联网进行通信

- 纵坐标表示「时间」

- 发送方给接收方发送数据分组，接收方收到后对其进行差错检测，若没有误码，则接收该数据分组，并给发送方发送「确认分组」，简称为 ACK

- 发送方收到对所发送数据分组的确认分组后，才能发送下一个数据分组

- 假设下一个数据分组在传输过程中出现了误码，接收方收到后对其进行差错检测，发现了误码，则丢弃该数据分组，并给发送方发送「否认分组」，简称为 NAK

- 发送方收到对所发送数据分组的否认分组后，就知道了之前自己所发送的数据分组出现了差错而被接收方拒绝

- 于是发送方立刻「重传」该数据分组（因此，发送方每发送完一个数据分组，并不能立刻将该数据分组从缓存中剔除，只有在收到针对该数据分组的确认分组后，才能将其从缓存中删除）

- 这样就实现了发送方发送什么，接收方最终就能收到什么，也就是所谓的可靠传输

<img src="https://gitee.com/pj-l/imgs-1/raw/master/image-20220317230318113.png" style="zoom:50%;" />

> 但实际情况远比我们想象的复杂，来看下面这种情况

- 发送方给接收方发送数据分组，然而该数据分组在传输过程中丢失了

- 注意：对于数据链路层点对点信道而言，不太容易出现这种情况；但对于多个网络通过多个路由器互连的复杂互联网环境而言，这种情况会经常出现

<img src="https://gitee.com/pj-l/imgs-1/raw/master/超时重传的原因.png" style="zoom:67%;" />

- 如下图所示，发送方超时重传之前所发送的数据分组

- 接收方正确接收重传的数据分组后，给发送方发送确认分组，发送方收到确认分组后，发送下一个数据分组，接收方正确接收该数据分组后，给发送方发送确认分组

- 到目前为止，貌似基于停止等待，使用确认或否认分组，再加上超时重传的手段，就可以实现可靠传输了
	
	<img src="https://gitee.com/pj-l/imgs-1/raw/master/image-20220318074635067.png" alt="image-20220318074635067" style="zoom:50%;" />

> 思考：是否还会出现其他情况，导致目前这些手段不足以保障可靠传输的实现 ？

- 以下图为例

- 既然发送方发送的数据分组可能丢失，那么接收方发送的确认或否认分组就也有可能丢失

- 例如发送方发送了一个数据分组，接收方正确接收该数据分组后，给发送方发送确认分组，但该确认分组在传输过程中丢失了

- 这必然会导致发送方对之前所发送数据分组的超时重传

- 假设这个超时重传的数据分组也正确到达了接收方

- 那么接收方如何判断该数据分组是一个重复的分组呢 ？

	- 为了避免分组重复这种传输错误，必须给每个分组都带上序号

	- 对于停止等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同即可

	- 因此用 1 个比特来编号就够了（即：序号 0 和 1）

	- 这样，根据数据分组的序号，接收方就可以判断出该数据分组是否是重复的

- 接收方会丢弃重复的数据分组，并给发送方发送针对该数据分组的确认分组，以免发送方对该数据分组的再次超时重传

- 发送方收到针对 0 号数据分组的确认分组后，就可以发送下一个数据分组了，其序号为 1

- 接收方正确收到 1 号数据分组后，给发送方发送确认分组

- ...

> 我们通过确认分组丢失的情况，引出了给数据分组编号的问题
>
> 思考：既然数据分组需要编号，那么确认分组是否也需要编号呢 ？