## 可靠传输的实现机制之（停止等待协议SW）

- 如图所示，收发双方并不局限于一条点对点的数据链路，而是基于互联网进行通信

- 纵坐标表示「时间」

- 发送方给接收方发送数据分组，接收方收到后对其进行差错检测，若没有误码，则接收该数据分组，并给发送方发送「确认分组」，简称为 ACK

- 发送方收到对所发送数据分组的确认分组后，才能发送下一个数据分组

- 假设下一个数据分组在传输过程中出现了误码，接收方收到后对其进行差错检测，发现了误码，则丢弃该数据分组，并给发送方发送「否认分组」，简称为 NAK

- 发送方收到对所发送数据分组的否认分组后，就知道了之前自己所发送的数据分组出现了差错而被接收方拒绝

- 于是发送方立刻「重传」该数据分组（因此，发送方每发送完一个数据分组，并不能立刻将该数据分组从缓存中剔除，只有在收到针对该数据分组的确认分组后，才能将其从缓存中删除）

- 这样就实现了发送方发送什么，接收方最终就能收到什么，也就是所谓的可靠传输

<img src="https://gitee.com/pj-l/imgs-1/raw/master/image-20220317230318113.png" style="zoom:50%;" />

> 但实际情况远比我们想象的复杂，来看下面这种情况

- 发送方给接收方发送数据分组，然而该数据分组在传输过程中丢失了

- 注意：对于数据链路层点对点信道而言，不太容易出现这种情况；但对于多个网络通过多个路由器互连的复杂互联网环境而言，这种情况会经常出现

<img src="https://gitee.com/pj-l/imgs-1/raw/master/超时重传的原因.png" style="zoom:67%;" />

- 如下图所示，发送方超时重传之前所发送的数据分组

- 接收方正确接收重传的数据分组后，给发送方发送确认分组，发送方收到确认分组后，发送下一个数据分组，接收方正确接收该数据分组后，给发送方发送确认分组

- 到目前为止，貌似基于停止等待，使用确认或否认分组，再加上超时重传的手段，就可以实现可靠传输了
	
	<img src="https://gitee.com/pj-l/imgs-1/raw/master/image-20220318074635067.png" alt="image-20220318074635067" style="zoom:50%;" />

> 思考：是否还会出现其他情况，导致目前这些手段不足以保障可靠传输的实现 ？

- 以下图为例

- 既然发送方发送的数据分组可能丢失，那么接收方发送的确认或否认分组就也有可能丢失

- 例如发送方发送了一个数据分组，接收方正确接收该数据分组后，给发送方发送确认分组，但该确认分组在传输过程中丢失了

- 这必然会导致发送方对之前所发送数据分组的超时重传

- 假设这个超时重传的数据分组也正确到达了接收方

- 那么接收方如何判断该数据分组是一个重复的分组呢 ？

	- 为了避免分组重复这种传输错误，必须给每个分组都带上序号

	- 对于停止等待协议，由于每发送一个数据分组就停止等待，只要保证每发送一个新的数据分组，其发送序号与上次发送的数据分组的序号不同即可

	- 因此用 1 个比特来编号就够了（即：序号 0 和 1）

	- 这样，根据数据分组的序号，接收方就可以判断出该数据分组是否是重复的

- 接收方会丢弃重复的数据分组，并给发送方发送针对该数据分组的确认分组，以免发送方对该数据分组的再次超时重传

- 发送方收到针对 0 号数据分组的确认分组后，就可以发送下一个数据分组了，其序号为 1

- 接收方正确收到 1 号数据分组后，给发送方发送确认分组

- ...

<img src="https://gitee.com/pj-l/imgs-1/raw/master/image-20220318114635502.png" alt="image-20220318114635502" style="zoom:50%;" />

> 我们通过确认分组丢失的情况，引出了给数据分组编号的问题
>
> 思考：既然数据分组需要编号，那么确认分组是否也需要编号呢 ？

- 以下图为例

- 发送方发送 0 号数据分组，接收方正确接收后给发送方发送确认分组

- 由于某些原因，该确认分组迟到了，这必然会导致发送方对 0 号数据分组的超时重传

- 然后发送方收到了迟到的确认分组，于是发送 1 号数据分组

- 接收方收到重传的 0 号数据分组后，发现这是一个重复的数据分组，就会将其丢弃，并针对该数据分组给发送方发送确认分组，以免发送方再次超时重传该数据分组

- 问题来了，我们可以清楚地看到，对 0 号数据分组存在重复确认的情况，但是发送方又如何知道呢 ？

- 如果不采取其他措施的话，发送方就会误认为这是对 1 号数据分组的确认

<img src="https://gitee.com/pj-l/imgs-1/raw/master/image-20220318161137396.png" alt="image-20220318161137396" style="zoom:50%;" />

- 如果对确认分组也进行编号，就可以使发送方避免这种误判，如下图所示

- 两次确认分组的序号都是 0，发送方通过这个序号就能知道只是一个重复的确认分组，忽略即可

<img src="https://gitee.com/pj-l/imgs-1/raw/master/image-20220318161706078.png" alt="image-20220318161706078" style="zoom:50%;" />

> 注意：
>
> 对于数据链路层的点对点信道，往返时间比较固定，不会出现确认迟到的情况
>
> 因此：如果只在数据链路层实现停止等待协议，可以不用给确认分组编号

#### 停止等待协议的注意事项

![image-20220318162504875](https://gitee.com/pj-l/imgs-1/raw/master/image-20220318162504875.png)

#### 停止等待协议的信道利用率

- 如下图所示，横坐标为时间，为简单起见，假设收发双方是一条直通的信道

- 发送方发送完一个数据分组后就停止发送，并等待接收方对该数据分组的确认

- 当收到确认分组后，就可以发送下一个数据分组，如此反复进行...

- 名词解释：

	- TD（`T`ime `D`elay）：发送方发送数据分组所耗费的发送时延

	- RTT（`R`ound-`t`rip `t`ime）：收发双方之间的往返时间

	- TA（`A`ccept）：接收方发送确认分组所耗费的发送时延

- 注意：下图忽略了（接收方对数据分组的处理时延 & 发送方对确认分组的处理时延）

> 使用停止等待协议的发送方，从发送一个数据分组开始，到可以发送下一个数据分组为止，所经历的总时间为：TD+RTT+TA

- 由于仅仅是在时间 TD 内才用来传送有用的数据，即数据分组，因此信道的利用率计算公式如下图所示

![image-20220318163838917](https://gitee.com/pj-l/imgs-1/raw/master/image-20220318163838917.png)

> TA 一般远小于 TD，实际情况中可以忽略；所以，当 RTT 远大于 TD 时（例如使用卫星链路），信道利用率会非常低，举例如下

![image-20220318164231550](https://gitee.com/pj-l/imgs-1/raw/master/image-20220318164231550.png)

> 若出现重传，则对于传送有用的数据信息来说，信道利用率还要降低

![image-20220318164455382](https://gitee.com/pj-l/imgs-1/raw/master/image-20220318164455382.png)

#### 练习题

![image-20220318164732125](https://gitee.com/pj-l/imgs-1/raw/master/image-20220318164732125.png)

#### 小结

![image-20220318161926105](https://gitee.com/pj-l/imgs-1/raw/master/image-20220318161926105.png)

> 像停止等待协议这种通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ
> 
> 意思是重传的请求是自动进行的，不需要接收方显式地请求发送方重传某个出错的分组

![image-20220318165629703](https://gitee.com/pj-l/imgs-1/raw/master/image-20220318165629703.png)
